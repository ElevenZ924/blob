---
title: "gRPC 介绍"
date: 2024-07-06
tags: ["gRPC"]
---
# gRPC 简介

## 什么是 gRPC?

gRPC 一开始由 google 开发，是一款语言中立、平台中立、开源的远程过程调用(RPC)系统。在 gRPC 里客户端应用可以像调用本地对象一样直接调用另一台不同的机器上服务端应用的方法，使得能够更容易地创建分布式应用和服务。与许多 RPC 系统类似，gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。
![](assert/landing-2.svg)

- gRPC 默认使用 [protocol buffers](https://developers.google.com/protocol-buffers/) 作为接口定义语言，来描述服务接口和有效载荷消息结构。建议在 gRPC 里使用 proto3，因为这样可以使用 gRPC 支持全部范围的的语言，并且能避免 proto2 客户端与 proto3 服务端交互时出现的兼容性问题。
- gRPC 客户端和服务端可以在多种环境中运行和交互,可以很容易地用 Java 创建一个 gRPC 服务端，用 Go、Python、Ruby 来创建客户端。

## 服务定义

gRPC 基于定义一个服务的思想, 指定远程调用的方法及其参数和返回值类型, 默认情况下,gRPC 使用 protocol buffers 作为接口定义语言(IDL)来描述服务接口和负载消息的结构
示例:

```protocol
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```

gRPC 可以定义 4 中服务方法:

- Unary RPCs: 客户端向服务端发送一个请求,然后得到一个服务端返回的响应. 就像普通的函数一样

```
rpc SayHello(HelloRequest) returns (HelloResponse);
```

- Server streaming RPCs: 客户端向服务端发送一个请求,然后从从服务端获取到一个 stream, 从 stream 中可以读取到一系列返回到消息

```
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);
```

- Client streaming RPCs: 客户端使用 stream 向服务端发送一系列的消息,发送完成后,等待服务端从 stream 中读取数据,并返回一个响应

```
 rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);
```

- Bidirectional streaming RPCs: 服务端和客户端都使用 read-write stream 发送一系列消息, 这两个 stream 并不相互依赖, 所以客户端和服务端可以按照任意的顺序读写. 比如:服务器可以在接收到所有客户端消息后再写入响应，也可以交替读取一个消息，然后再写入一个消息，或者是其他读写的组合。每个流中的消息顺序被保留

```
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);
```

## 同步 / 异步

同步 RPC 调用, 会一直阻塞,直到服务端返回一个响应. 这与 RPC 希望的抽象最为接近。另一方面网络内部是异步的，并且在许多场景下能够在不阻塞当前线程的情况下启动 RPC 是非常有用的。

## 生命周期

### Unary RPC

- 一旦客户端通过桩调用一个方法，服务端会得到相关通知 ，通知包括客户端的元数据，方法名，允许的响应期限（如果可以的话）
- 服务端既可以在任何响应之前直接发送回初始的元数据，也可以等待客户端的请求信息，到底哪个先发生，取决于具体的应用。
- 一旦服务端获得客户端的请求信息，就会做所需的任何工作来创建或组装对应的响应。如果成功的话，这个响应会和包含状态码以及可选的状态信息等状态明细及可选的追踪信息返回给客户端 。
- 假如状态是 OK 的话，客户端会得到应答，这将结束客户端的调用。

### Server streaming RPC

服务端流式 RPC 除了在得到客户端请求信息后发送回一个应答流之外，与我们的简单例子一样。在发送完所有应答后，服务端的状态详情(状态码和可选的状态信息)和可选的跟踪元数据被发送回客户端，以此来完成服务端的工作。客户端在接收到所有服务端的应答后也完成了工作。

### Client streaming RPC

客户端流式 RPC 也基本与我们的简单例子一样，区别在于客户端通过发送一个请求流给服务端，取代了原先发送的单个请求。服务端通常（但并不必须）会在接收到客户端所有的请求后发送回一个应答，其中附带有它的状态详情和可选的跟踪数据。

### Bidirectional streaming RPC

双向流式 RPC ，调用由客户端调用方法来初始化，而服务端则接收到客户端的元数据，方法名和截止时间。服务端可以选择发送回它的初始元数据或等待客户端发送请求。
下一步怎样发展取决于应用，因为客户端和服务端能在任意顺序上读写 - 这些流的操作是完全独立的。例如服务端可以一直等直到它接收到所有客户端的消息才写应答，或者服务端和客户端可以像"乒乓球"一样：服务端后得到一个请求就回送一个应答，接着客户端根据应答来发送另一个请求，以此类推。

## Deadlines/Timeouts

gRPC 允许客户端在调用一个远程方法前指定一个最后期限值。这个值指定了在客户端可以等待服务端多长时间来应答，超过这个时间值 RPC 将结束并返回`DEADLINE_EXCEEDED`错误。在服务端可以查询这个期限值来看是否一个特定的方法已经过期，或者还剩多长时间来完成这个方法。
各语言来指定一个截止时间的方式是不同的 - 比如在 Python 里一个截止时间值总是必须的，但并不是所有语言都有一个默认的截止时间。

## RPC termination

在 gRPC 里，客户端和服务端对调用成功的判断是独立的、本地的，他们的结论可能不一致。这意味着，比如你有一个 RPC 在服务端成功结束("我已经返回了所有应答!")，到那时在客户端可能是失败的("应答在最后期限后才来到!")。也可能在客户端把所有请求发送完前，服务端却判断调用已经完成了。

## 取消 RPC

无论客户端还是服务端均可以再任何时间取消一个 RPC 。一个取消会立即终止 RPC 这样可以避免更多操作被执行。它不是一个"撤销"， 在取消前已经完成的不会被回滚。当然，通过同步调用的 RPC 不能被取消，因为直到 RPC 结束前，程序控制权还没有交还给应用。

## Metadata

元数据是一个特殊 RPC 调用对应的信息(授权详情]) ，这些信息以键值对的形式存在，一般键的类型是字符串，值的类型一般也是字符串(当然也可以是二进制数据)。元数据对 gRPC 本身来说是不透明的 - 它让客户端提供调用相关的信息给服务端，反之亦然。
键不区分大小写，由 ascii 字母、数字和特殊字符-、组成。并且不能以 grpc-开头(这是为 grpc 本身保留的)。二进制值的键以-bin 结尾，而 ascll 值的键则不是。
对于元数据的访问是语言相关的。

## Channels

在创建客户端存根时，一个 gRPC 频道提供一个特定主机和端口服务端的连接。客户端可以通过指定频道参数来修改 gRPC 的默认行为，比如打开关闭消息压缩。一个频道具有状态，包含`已连接`和`空闲` 。
gRPC 如何处理关闭频道是语言相关的。有些语言可允许询问频道状态。
